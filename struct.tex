% 1. Structure of the language

\chapter{Schemeの概観}

\section{意味論}
\label{semanticsection}

本節は Scheme の意味論の概観を与える。
詳細な非形式的意味論は\ref{basicchapter}章から\ref{builtinchapter}章で論ずる。
典拠として，\ref{formalsemanticssection}節は Scheme の形式的な意味論を定める。

\vest Scheme は静的スコープをもつプログラミング言語である。
変数の各使用は，その変数の字句的に見かけの束縛に関連している。

\vest Scheme は動的型付き言語である。
型は変数ではなく，値(オブジェクト\mainindex{object}とも呼ばれる)に関連付けられている。
静的型付き言語は，対照的に，値と同じように変数と式に型を関連付ける。

\vest 手続きや継続 (continuation) を含む， Scheme の計算過程で作成されたすべてのオブジェクトは，無期限の寿命 (extent) をもっている。
Schemeのオブジェクトは，破壊されることはない。
Scheme の実装が (通常は!) 記憶領域を使い果たさない理由は，あるオブジェクトが将来のいかなる計算にも関係ないことを証明できれば，オブジェクトが占める記憶領域を再利用することを許可されているためである。

\vest Scheme の実装は真正に末尾再帰的 (properly tail-recursive) であることが必須である。
これは，反復計算が構文的に再帰的な手続きで記述されている場合でも，一定の空間における反復計算の実行を可能にする。
このように真正に末尾再帰的な実装では，特別な反復コンストラクトは，糖衣構文としてのみ有用であるように，反復は通常の手続き呼び出しの仕組みを使って表現することができる。
\ref{proper tail recursion}節を見よ。

\vest Scheme の手続きはそれ自体でオブジェクトである。
手続きを動的に作成すること，データ構造の中に格納すること，
手続きの結果として返すことなどが可能である。

\vest Scheme の一つ際立った特徴は，他のほとんどの言語ではただ舞台裏での演算である継続が，``第一級'' の地位も持っているということである。
第一級の継続は，非局所的脱出，バックトラッキング，およびコルーチンを含むバラエティに富んだ高度な制御構造を実装するのに有用である。
\ref{continuations}節を見よ。

\vest Scheme の手続きへの引数は常に値によって渡される。
これは，手続きが評価結果を必要とするか否かにかかわらず，
手続きが制御を得る前に実引数の式が評価されることを意味する。

\vest Scheme の算術モデルは計算機内部での数の特定の表現方法からできる限り
独立を保つように設計されている。
Scheme では，あらゆる整数は有理数であり，あらゆる有理数は実数であり，
あらゆる実数は複素数である。
したがって，整数算術と実数算術の区別は，多くのプログラミング言語にとっては
とても重要であるが，Scheme には現れない。
そのかわり，数学的理想に相当する正確算術 (exact arithmetic) と
近似に基づく不正確算術の区別がある。
正確算術は整数に限られない。

\section{構文}

Scheme は，Lisp の大多数の方言と同じく，プログラムとそれ以外のデータを
表すために，省略なくカッコでくくられた前置表記を使用する。
Scheme の文法は，データを表すために使われる言語の，部分言語を生成する。
この単純さの結果として，一様な表現は，Scheme プログラムやデータを
容易に他の Scheme プログラムによって一様に扱うことができる。
たとえば {\cf eval} 手続きは，データとして表現された Scheme プログラムを
評価する。

{\cf read} 手続きは，字句だけでなく構文も解析してデータを読む。
{\cf read} 手続きは入力をプログラムとしてではなく
データ (\ref{datumsyntax} 節) としてパースする。

Scheme の形式的な構文は\ref{BNF}節で記述する。


\section{表記と用語}


\subsection{基本およびオプション機能}
\label{qualifiers}

本報告書で定義されているすべての識別子は，1つまたはいくつかのライブラリ (\defining{libraries}) に表れる。
基本ライブラリ (\defining{base library}) で定義された識別子は，報告書の本文に特別にマークされていない。
このライブラリは，Scheme のコア構文と一般的に有用なデータ操作手続きを含んでいる。
たとえば，変数 {\cf abs} は数の絶対値を計算する1引数の手続きに束縛されており，
変数 {\cf +} は和を計算する手続きに束縛されている。
それらがエクスポートするすべての標準ライブラリや識別子の完全なリストは，
付録~\ref{stdlibraries}に記載されている。

Scheme のすべての実装において:
\begin{itemize}

\item 基本ライブラリと，そこからエクスポートされたすべての識別子を提供しなければならない。

\item 本報告書に記載された他のライブラリを提供または省略してもよいが，
各ライブラリは，追加の識別子をエクスポートすることなくその全体が提供される，
または完全に省略される，のいずれかでなければならない。

\item 本報告書に記載されていない他のライブラリを提供してもよい。

\item また，本報告書中の任意の識別子の関数を拡張してもよく，
提供される拡張機能はここで報告された言語と矛盾しない。

\item 字句構文が本報告書に記載された字句構文と競合しないような動作モードを
提供することにより，移植可能なコードをサポートしなければならない。
\end{itemize}

\subsection{エラー状態と未規定の振舞い}
\label{errorsituations}

\mainindex{error}
エラー状態について言うとき，本報告書は ``エラーが通知される'' という
表現を使って，実装がそのエラーを検出し報告しなければならないことを示す。
エラーは，~\ref{exceptionsection}節で記述された手続き {\cf raise}
のように継続不能な例外を発生させることで通知される。
発生させたたオブジェクトは実装依存であり，以前に同じ目的のために使われた
オブジェクトとは別である必要はない。
本報告書に記載された状況でのエラー通知に加えて，
プログラマは自身のエラー通知し，通知されたエラーを処理することができる。

語句 `` {\em 述語}を満たすエラーが通知される'' とは，エラーが上記のように通知されることを意味する。
さらに，通知されるオブジェクトが指定した({\cf file-error?} または {\cf read-error?} のような)
述語に渡される場合，述語は \schtrue{} を返す。

\vest もしあるエラーの議論にそのような言い回しが現れないならば，
実装がそのエラーを検出または報告することは，
奨励されているが，必須ではない。
そのような状況は時々，常にではないが，語句 ``エラー'' と呼ばれる。
このような状況では，実装はエラーを通知してもよいし，しなくてもよい。
もしエラーを通知する場合は，通知されるオブジェクトは述語
{\cf error-object?}，{\cf file-error?} または{\cf read-error?} を
満たしてもよいし，満たさなくてもよい。
代わりに，実装は移植性のない拡張機能を提供してもよい。

たとえば，ある手続きにその手続きで処理することが明示的に規定されていない型の
引数を渡すことは，たとえそのような定義域エラーが本報告書でほとんど言及
されていなくても，エラーである。
実装は，エラーを通知するか，そのような引数を含めるように手続きの定義域を拡張するか，
壊滅的に失敗してもよい。

\vest 本報告書は ``実装制限の違反を報告してもよい'' という表現を使って，
実装の課すなんらかの制限のために正当なプログラムの実行を続行できない，
と報告することが実装に許可されている状況を示す。
実装制限は望ましくないが，実装が実装制限の違反を報告することは
奨励されている。\mainindex{implementation restriction}

\vest たとえば実装は，あるプログラムを走らせるだけの十分な記憶領域がないとき，
あるいは，算術演算が実装において大きすぎて表現できないな正確数を生成するとき，
実装制限の違反を報告してもよい。

\vest もしある式の値が ``未規定'' (unspecified) であると述べられているならば，
その式は，エラーが通知されることなく，なんらかのオブジェクトへと
評価されなければならない。しかし，その値は実装に依存する。
本報告書は，
どんな値が返されるかを明示的には述べない。\mainindex{unspecified}

\vest 最後に，単語やフレーズ ``しなければならない(must),'' ``してはならない(must not),''
``するものとする(shall),'' ``しないものとする(shall not),'' ``すべきである(should),''
``すべきではない(should not),'' ``してもよい(may),'' ``必須である(required),''
``推奨される(recommended),'' ならびに ``任意である(optional)''
は，本報告書に大文字で書かれてはいないが，RFC~2119~\cite{rfc2119} で説明されているように
解釈されるべきである。
それらは実装者あるいは実装の振舞いに関してのみ使用され，
プログラマやプログラムの振舞いに関してではない。



\subsection{エントリの書式}

エントリごとにまとめられている。
各エントリは一つの言語機能，
または関連する複数の機能からなる一つのグループを記述する。
ただし，ここで機能とは構文コンストラクトまたは手続きのことである。
エントリは下記の書式の 1 行以上の見出しで始まる。
基本ライブラリ中の識別子ならば，


\noindent\pproto{\var{template}}{\var{category}}\unpenalty

そうでなければ，

\noindent\pproto{\var{template}}{\var{name} library \var{category}}\unpenalty

ここで \var{name} は付録~\ref{stdlibraries} で定義されているライブラリの短縮名である。

もし \var{category} が ``\exprtype'' ならば，
そのエントリは式型を記述し，template はその式型の構文を与える。
式の構成要素は構文変数によって示される。
構文変数は \hyper{式}，\hyper{変数} のように山形カッコを使って書かれる。
構文変数はプログラムテキストのそれぞれの部分を表すことが意図されている。
たとえば \hyper{式} は，構文的に妥当な一つの式である任意の文字の列を表す。
表記
\begin{tabbing}
\qquad \hyperi{なにか} $\ldots$
\end{tabbing}
は \hyper{なにか} の 0 個以上の出現を示し，
\begin{tabbing}
\qquad \hyperi{なにか} \hyperii{なにか} $\ldots$
\end{tabbing}
は \hyper{なにか} の 1 個以上の出現を示す。

もし \var{category} が ``補助構文'' ならば，そのエントリは
特定の囲まれた式の一部としてのみ起こる構文束縛を記述する。
独立した構文構造や変数としてのいかなる使用もエラーである。

もし \var{category} が ``手続き'' ならば，そのエントリは手続きを記述し，
見出し行はその手続きの呼出しを表すテンプレートを与える。
テンプレートの中の引数名は \var{italic} 体で書かれる。
したがって見出し行

\noindent\pproto{(vector-ref \var{vector} \var{k})}{手続き}\unpenalty

は {\tt vector-ref} に束縛された手続きが二つの引数，ベクタ \var{vector} と
正確非負整数 \var{k} (下記参照) をとることを示す。
見出し行

\noindent%
\pproto{(make-vector \var{k})}{手続き}
\pproto{(make-vector \var{k} \var{fill})}{手続き}\unpenalty

は {\tt make-vector} 手続きが一つまたは二つの引数をとるように
定義されなければならないことを示す。

\label{typeconventions}
ある演算に対し処理することが規定されていない引数を与えることはエラーである。
簡潔のため我々は，もし引数名が\ref{disjointness}節に挙げられた型の名前でも
あるならばその引数はその引数が名前付けられた型のものでない場合はエラーである，という規約に従う。
たとえば上記の {\tt vector-ref} の見出し行は，{\tt vector-ref} の第１引数が
ベクタでなければならないことを命じている。
以下の命名規約もまた型の制約を意味する。
\newcommand{\foo}[1]{\vr{#1}, \vri{#1}, $\ldots$ \vrj{#1}, $\ldots$}
$$
\begin{tabular}{ll}
\vr{alist}&association list (list of pairs)\\
\vr{boolean}&論理値 (\schtrue{} or \schfalse{})\\
\vr{byte}&正確整数 $0 \leq byte < 256$\\
\vr{bytevector}&バイトベクタ\\
\vr{char}&文字\\
\vr{end}&正確非負整数\\
\foo{k}&正確非負整数\\
\vr{letter}&英字\\
\foo{list}&リスト (\ref{listsection}節参照)\\
\foo{n}&整数\\
\var{obj}&任意のオブジェクト\\
\vr{pair}&pair\\
\vr{port}&port\\
\vr{proc}&procedure\\
\foo{q}&有理数\\
\vr{start}&正確非負整数\\
\vr{string}&文字列\\
\vr{symbol}&symbol\\
\vr{thunk}&zero-argument procedure\\
\vr{vector}&ベクタ\\
\foo{x}&実数\\
\foo{y}&実数\\
\foo{z}&複素数\\
\end{tabular}
$$

名前 \vr{start} および \vr{end} は，文字列，ベクタ，およびバイトベクタの添字として使われる。
これらの使用は，次のことを意味する:

\begin{itemize}

\item{\var{start} が \var{end} より大きければエラーである。}

\item{\var{end} が文字列，ベクタ，バイトベクタの長さよりも大きければエラーである。}

\item{\var{start} が省略された場合，ゼロとみなす。}

\item{\var{end} が省略された場合，文字列，ベクタ，バイトベクタの長さとみなす。}

\item{添字 \var{start} は常に含まれ，添字 \var{end} は常に含まない。
例として，文字列を考える。
もしも \var{start} と \var{end} が同じならば
空の部分文字列のことになり，
もしも \var{start} がゼロであって \var{end} が \var{string} の長さならば
文字列全体のことになる。}

\end{itemize}

\subsection{評価の例}

プログラム例で使われる記号 ``\evalsto'' は ``へと評価される'' と
読む。たとえば，

\begin{scheme}
(* 5 8)      \ev  40%
\end{scheme}

は式 {\tt(* 5 8)} がオブジェクト {\tt40} へと評価されることを意味する。
つまり，より正確には，文字の列 ``{\tt(* 5 8)}'' によって与えられる式が，
文字の列 ``{\tt 40}'' によって外部的に表現され得るあるオブジェクトへと，
初期環境の中で評価されることを意味する。
オブジェクトの外部表現の議論については\ref{externalreps}節を見よ。

\subsection{命名規約}

規約により，\ide{?} は常にブーリアン値を返す手続きの名前の最後の文字である。
このような手続きは述語 (predicate) と呼ばれる。
述語は，引数の型が間違って渡されたときに例外を起こしてもよいことを除いて，一般的に副作用がないと理解される。

同様に，\ide{!} は，以前に割り当てられた場所の中へ値を格納する
手続き (\ref{storagemodel}節参照)の名前の最後の文字である。
このような手続きは書換え手続き (\defining{mutation procedure}) と呼ばれる。
書換え手続きが返す値は未規定である。

規約により，ある型のオブジェクトをとって別の型の相当するオブジェクトを返す
手続きの名前の途中には ``\ide{->}'' が現れる。
たとえば {\cf list->vector} は，
一つのリストをとって，そのリストと同じ要素からなるベクタを返す。

コマンド (\defining{command}) は，その継続に有用な値を返さない手続きである。
	
サンク (\defining{thunk}) は，引数を受け取らない手続きである。
