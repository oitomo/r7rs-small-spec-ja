\chapter*{Schemeの概観}

本稿では，\rsevenrs の小さな言語の概要を説明する。
この概要の目的は，リファレンスマニュアルのように構成された \rsevenrs{} 報告書の理解を容易にするために，言語の基本的な概念について十分に説明することである。
したがって，この概要はいかなる意味においても，言語への完全な導入でなければ，すべての点や規範において正確でもない。

\vest Algol に続いて， Scheme は静的スコープのプログラミング言語である。
変数の各使用は，その変数の字句的に見かけの束縛に関連している。

\vest Schemeは，明示型とは対照的に，潜在型をもつ。
型は，変数ではなくオブジェクト(値とも呼ばれる)と関連している。
(一部の著者は，潜在型の言語を，型指定されていない，弱い型付けまたは動的型付け言語と呼ぶ。)
潜在型の他の言語は，Python や Ruby, Smalltalk, そして他の Lisp 方言である。
明示型の言語 (時々強い型付け，または静的型付け言語と呼ばれる) には， Algol 60, C, C\#, Java, Haskell, および ML が含まれている。

\vest 手続きや継続を含む， Scheme の計算過程で作成されたすべてのオブジェクトは，無制限の範囲をもっている。
Schemeのオブジェクトは，破壊されることはない。
Scheme の実装が (通常は!) ストレージが不足しない理由は，オブジェクトが，おそらく将来の計算には関係ないことをそれらが証明できれば，オブジェクトが占有するストレージをそれらが再利用することを許可されていることである。
ほとんどのオブジェクトが無制限の範囲をもっている他の言語は， C\#, Java, Haskell, ほとんどの Lisp 方言, ML, Python, Ruby, and Smalltalk がある。

Schemeの実装は，適切に末尾再帰でなければならない。
これは，反復計算が構文的に再帰的な手続きによって記述されている場合でも，一定の空間における反復計算の実行を可能にする。
このように適切な末尾再帰の実装で，特別な反復コンストラクトは，糖衣構文としてのみ有用であるように，反復は通常の手続き呼び出しの仕組みを使って表現することができる。

\vest Schemeは，それ自体がオブジェクトとして手続きをサポートする最初の言語の一つであった。
手続きは動的に作成することができ，データ構造に格納されて，手続きの結果として返される，などである。
これらの特性を有する他の言語は，Common Lisp, Haskell, ML, Ruby, そして Smalltalk がある。

\vest Scheme の一つ際立った特徴は，他のほとんどの言語では背後での演算のみである継続が，``第一級'' ステータスも持っているということである。
第一級の継続は，非局所的脱出，バックトラック，およびコルーチンを含むバラエティに富んだ高度な制御構造を実装するのに有用である。

Schemeでは，手続き呼び出しの引数の式は，手続きが評価の結果を​​必要とするかどうかによらず，手続きが制御を取得する前に評価される。
C, C\#, Common Lisp, Python, Ruby, そして Smalltalk は，常に手続きを呼び出す前に引数の式を評価する他の言語である。
これは，その値が手続きで必要とされない限り，引数の式が評価されない Haskell のの遅延評価の意味や， Algol 60 の名前呼びの意味とは異なる。

Scheme の算術演算モデルは，数値型と演算の豊富な集合を提供する。
これはさらに，\textit{正確}と\textit{不正確}数を区別する: 
基本的に，正確数オブジェクトは正しく数値に対応しており，不正確数は丸めや他の近似に関連する計算結果である。

\chapter{基本型}

Scheme のプログラムは，\textit{値}とも呼ばれている\textit{オブジェクト}を，操作する。
Scheme のオブジェクトは \textit{型}と呼ばれる値の集合で編成されている。
本章では，Scheme 言語の基本的に重要な型の概要を説明する。

\begin{note}
  Scheme は潜在的に型指定されているので， Scheme の文脈における用語 \textit{型} の使用は，他の言語，特に明示型のもの，の文脈における用語の使用とは異なる。
\end{note}

\paragraph{数}

Schemeは，任意の精度の整数，有理数，複素数，および様々な種類の不正確数を含むバラエティ豊かな数値データ型をサポートする。

\paragraph{ブーリアン}

ブーリアンは，真偽値であり，真または偽のいずれかである。
Schemeでは， ``偽'' のオブジェクトは， \schfalse{} と書かれる。
``真'' のオブジェクトは， \schtrue{} と書かれる。
しかし，真偽値が期待されているほとんどの場所では，\schfalse{} とは異なる任意のオブジェクトは，真と数えられる。

\paragraph{ペアとリスト}

ペアは，二つの構成要素を有するデータ構造である。
ペアの最も一般的な用途は，第一構成要素 (``car'') はリストの最初の要素を表しており，第二構成要素 (``cdr'') リストの残りであるような (片方向) リストを表すことである。
Scheme は，リストを形成するペアのチェーンの最後の cdr である，区別された空のリストも持っている。

\paragraph{シンボル}

シンボルは，文字列を表すオブジェクトであり，シンボルの \textit{名前} である。
文字列とは異なり，名前が同じように綴られている二つのシンボルが区別されることはない。
シンボルは，多くの用途に有用である; 例えば，それらは，列挙された値が他の言語で使われている方法を用いることができる。
% Symbols are useful for many applications; for instance, they can be used the way enumerated values are used in other languages.

\rsevenrs では， \rfivers とは異なり，シンボルと識別子は大文字と小文字が区別される。

\paragraph{文字}

Scheme の文字は，ほとんどテキスト文字に対応している。
より正確には，可能な実装依存の拡張でそれらは Unicode 標準の\textit{スカラ値}の部分集合と同型である。

\paragraph{文字列}

文字列は固定長の文字の有限列であり，したがって，任意の Unicode テキストを表す。

\paragraph{ベクタ}

ベクタは，リストのように，任意のオブジェクトの有限列を表す線形データ構造である。
リストの要素は，それを表すペアの連鎖を通じて順にアクセスされるのに対し，ベクタの要素は，整数の添字によってアドレス指定される。
このように，ベクタは，リストよりも要素へのランダムアクセスに適している。

\paragraph{バイトベクタ}

バイトベクタは，その内容が 0 から 255 までの範囲の正確整数である\textit{バイト}ということを除いて，ベクタに似ている。

\paragraph{手続き}

手続きは，Scheme 内の値である。

\paragraph{レコード型}

レコードは，構造化された値であり，各々が単一の場所を保持しているゼロ個以上の\textit{フィールド}の集計である。
レコードは，\textit{レコード型}に編成されている。
述語，コンストラクタ，およびフィールドアクセサとミューテータは，各レコード型のために定義することができる。

\paragraph{ポート}

ポートは，入出力デバイスを表す。
入力ポートは，コマンドに応じたデータを Scheme に配送することができる Scheme オブジェクトであると同時に，
出力ポートは，データを受理することができる Scheme オブジェクトである。

\chapter{式}

Scheme コードの最も重要な要素は，\textit{式}である。
式は\textit{評価}され，\textit{値}を生成することができる
(実際には，任意個の値。)
最も基本的な式はリテラル式である:

\begin{scheme}
\schtrue{} \ev \schtrue
23 \ev 23%
\end{scheme}

この表記は，式 \schtrue{} が \schtrue{} ，すなわち，``真''の値に評価され，
式 {\cf 23} が数値 23 を表す数に評価されることを意味する。

複合式は，その部分式の前後に括弧を置くことによって形成される。
最初の部分式は，演算子を識別する; 残りの部分式は，演算子のオペランドである:
%
\begin{scheme}
(+ 23 42) \ev 65
(+ 14 (* 23 42)) \ev 980%
\end{scheme}
%
これらの例の最初では， {\cf +} は加算のための組み込み演算子の名前で，{\cf 23} と {\cf 42} がオペランドである。
式 {\cf (+ 23 42)} は， ``23と42の和'' として読み出される。
複合式は入れ子にすることができる---二番目の例では，``14と，23と42の積との和''として読み出される。

これらの例が示すように， Scheme 中の複合式は，常に同じ接頭辞表記を使用して書かれている。
結果として，括弧は，構造を示すために必要とされる。
したがって，数学的記法や多くのプログラミング言語でも，多くの場合許容される ``余分な'' 括弧は， Scheme では許可されない。

(行末を含む) 空白は，式の部分式を分離し，構造を示すために使用することができる場合に，他の多くの言語同様，重要ではない。

\chapter{変数と束縛}

Schemeは，識別子が値を含んでいる場所を表すことを可能にする。
これらの識別子は，変数と呼ばれる。
多くの場合，特に，場所の値が，作成後に変更されることがないとき，値を直接表している変数と考えると便利である。

\begin{scheme}
(let ((x 23)
      (y 42))
  (+ x y)) \ev 65%
\end{scheme}

この場合は， {\cf let} で始まる式は束縛コンストラクトである。
{\cf let​​} に続く括弧で囲まれた構造は，変数の横に並んだ式を一覧にしている: 変数 {\cf x} に {\cf 23} が並び，変数 {\cf y} に {\cf 42} が並んでいる。
{\cf let} 式が {\cf x} に 23 を， {\cf y} に 42 を束縛する。
これらの束縛は， {\cf let} 式の\textit{本体} {\cf (+ x y)} ，およびそこだけで利用可能である。
% The parenthesized structure following the {\cf let} lists variables alongside expressions: the variable {\cf x} alongside {\cf 23}, and the variable {\cf y} alongside {\cf 42}.  
% The {\cf let} expression binds {\cf x} to 23, and {\cf y} to 42.  
% These bindings are available in the \textit{body} of the {\cf let} expression, {\cf (+ x y)}, and only there.

\chapter{定義}

{\cf let} 式によって束縛された変数は，その束縛が {\cf let} の本体でのみ可視なので， \textit{局所的} である。
Scheme は，次のように識別子のトップレベルの束縛の作成を可能にする:

\begin{scheme}
(define x 23)
(define y 42)
(+ x y) \ev 65%
\end{scheme}

(これらは実際に，トップレベルのプログラムやライブラリの本体の ``トップレベル'' にある。)

最初の二つの括弧で囲まれた構造が\textit{定義}である;
それらはトップレベルの束縛を作成し，{\cf x} に 23 を， {\cf y} に 42 を束縛する。
定義は式ではなく，式が発生することができるすべての場所に現れることはできない。
さらに，定義は値をもたない。

束縛は，プログラムの字句構造に従う:
同じ名前の束縛が複数存在する場合，変数は，プログラムでの発生から始めて内側から外側に向かって，最も近い束縛を参照し，局所的な束縛が途中で見つからない場合は最も外側の束縛を参照する:

\begin{scheme}
(define x 23)
(define y 42)
(let ((y 43))
  (+ x y)) \ev 66

(let ((y 43))
  (let ((y 44))
    (+ x y))) \ev 67%
\end{scheme}

\chapter{手続き}

定義は，手続きを定義するためにも使用することができる:

\begin{scheme}
(define (f x)
  (+ x 42))

(f 23) \ev 65%
\end{scheme}

やや単純化するが，手続きは，オブジェクトに対する式を抽象化したものである。
この例では，最初の定義は， {\cf f} と呼ばれる手続きを定義している。
(これは手続きの定義であることを示す {\cf f x} を括弧で囲むことに注意せよ。)
式 {\cf (f 23)} は手続き呼び出しの意味で，大体， ``{\cf (+ x 42)} (手続き本体) を， 23 に束縛された {\cf x} で評価する''。

手続きはオブジェクトなので，それらは他の手続きに渡すことができる:
%
\begin{scheme}
(define (f x)
  (+ x 42))

(define (g p x)
  (p x))

(g f 23) \ev 65%
\end{scheme}

この例では， {\cf g} の本体は {\cf f} で束縛された {\cf p} と， 23 で束縛された {\cf x} で評価され，それは {\cf (f 23)} と等価であり， 65 と評価される。

実際には， Scheme のあらかじめ定義された多くの演算は，構文によってではなく，その値が手続きである変数によって提供されている。
たとえば， {\cf +} 演算は，他の多くの言語で特別な構文上の扱いを受けて受け取るが，Scheme においては数を加算する手続きに束縛されているただの通常の識別子である。
同じことが， {\cf *} や他の多くで成り立つ:

\begin{scheme}
(define (h op x y)
  (op x y))

(h + 23 42) \ev 65
(h * 23 42) \ev 966%
\end{scheme}

手続き定義は，手続きを作成するための唯一の方法ではない。
{\cf lambda}式は，名を指定しなくても，オブジェクトとして新しい手続きを作成する:

\begin{scheme}
((lambda (x) (+ x 42)) 23) \ev 65%
\end{scheme}

この例の式全体が手続き呼び出しである; {\cf (lambda (x) (+ x 42))} は，一つの数をとり，それに42を加算する手続きに評価される。

\chapter{手続き呼び出しと構文キーワード}

{\cf (+ 23 42)}, {\cf (f 23)}, および {\cf ((lambda (x) (+ x 42)) 23)} がすべて手続き呼び出しの例であるのに対し，{\cf lambda} および {\cf let} 式はそうではない。
これは， {\cf let} は識別子であったとしても変数でなく，その代わりに \textit{構文キーワード} だからである。
その最初の部分式として構文キーワードをもっているリストは，キーワードによって決定される特別な規則に従う。
定義中の {\cf define} 識別子もまた構文キーワードである。
そのため，定義もまた手続き呼び出しではない。

{\cf lambda} キーワードのルールは，最初の部分リストはパラメータのリストであり，残りの部分リストは手続きの本体であることを指定する。
{\cf let} 式では，最初の部分リストは束縛仕様のリストであり，残りの部分リストは式の本体を構成している。

手続き呼び出しは，リストの最初の位置で構文キーワードを探すことによって，これらの\textit{式型}と区別することができる:
最初の位置に構文キーワードが含まれていない場合，式は手続き呼び出しである。
Scheme の構文キーワードの集合は通常，この作業をかなり簡単にし，かなり小さい。
しかしこれは，構文キーワードの新しい束縛を作成することが可能である。

\chapter{代入}

定義または {\cf let} または {\cf lambda} 式によって束縛される Scheme の変数は，実際には直接それぞれの束縛に指定されたオブジェクトにではなく，これらのオブジェクトを格納している場所へ束縛される。
これらの場所の内容は，続く\textit{代入}を通じて破壊的に変更することができる:
%
\begin{scheme}
(let ((x 23))
  (set! x 42)
  x) \ev 42%
\end{scheme}

この場合，{\cf let} 式の本体は，最終的な式の値が {\cf let} 式全体の値になるという，順次評価される二つの式で構成されている。
式 {\cf (set! x 42)} は代入であり， ``{\cf x} で参照される場所のオブジェクトを 42 に置換する'' と言う。
こうして， {\cf x} の以前の値 23 は， 42 に置き換えられる。

\chapter{派生構文とマクロ}

\rsevenrs{} の小さな言語の一部として指定された式の型の多くは，より基本的な式型に変換することができる。
たとえば，{\cf let} 式は，手続き呼び出しと {\cf lambda} 式に変換することができる。
次の二つの式は等価である:

%
\begin{scheme}
(let ((x 23)
      (y 42))
  (+ x y)) \ev 65

((lambda (x y) (+ x y)) 23 42) \lev 65%
\end{scheme}

{\cf let} 式のような構文式は，その意味が，構文的変換による式の他の種類のものから派生することができるので，\textit{派生}と呼ばれている。
いくつかの手続きの定義もまた派生式である。
次の二つの定義は等価である:

\begin{scheme}
(define (f x)
  (+ x 42))

(define f
  (lambda (x)
    (+ x 42)))%
\end{scheme}

Scheme では，マクロに構文キーワードを束縛することによって独自の派生式を作成するためのプログラムが可能である。

\begin{scheme}
(define-syntax def
  (syntax-rules ()
    ((def f (p ...) body)
     (define (f p ...)
       body))))

(def f (x)
  (+ x 42))%
\end{scheme}

{\cf define-syntax} コンストラクトは，パターン {\cf (def f (p ...) body)} に一致する括弧で囲まれた構造を指定し，それは式に変換される。
ここで {\cf f}, {\cf p}, および {\cf body} はパターン変数である。
こうして，例で示す {\cf def} 式は次に変換される:

\begin{scheme}
(define (f x)
  (+ x 42))%
\end{scheme}

新しい構文キーワードを作成する機能は，他の言語に組み込まれている機能の多くが Scheme で直接実装されることを可能にし， Scheme を非常に柔軟で表現力豊かにする:任意の Scheme プログラマは，新しい式型を追加することができる。

\chapter{構文上のデータとデータ値}

\textit{データ値}は Scheme オブジェクトのサブセットを構成する。
これらには，ブーリアン，数字，文字，シンボル，文字列だけでなく，その要素がデータ値であるリスト，ベクタ，およびバイトベクタが含まれている。
各データ値は，情報を失うことなく背後で読み書きができる\textit{構文的データ}としてテキストで表すことができる。
各データ値に対応する一つ以上の構文データが，一般的に存在する。
さらに，各データ値は，対応する構文データの先頭に {\cf\singlequote} を付加することで，プログラム内のリテラル式に自明に変換することができる:

\begin{scheme}
'23 \ev 23
'\schtrue{} \ev \schtrue{}
'foo \ev foo
'(1 2 3) \ev (1 2 3)
'\#(1 2 3) \ev \#(1 2 3)%
\end{scheme}

前の例で示される {\cf\singlequote} は，シンボルとリスト以外のリテラル定数の表現のために必要とされていない。
構文データ {\cf foo} は ``foo'' という名前をもつシンボルを表し， {\cf 'foo} はその値としてのシンボルをもつリテラル式である。
{\cf (1 2 3)} は要素 1, 2, 3 をもつリストを表す構文データであり， {\cf '(1 2 3)} はその値としてこのリストをもつリテラル式である。
同様に， {\cf \#(1 2 3)} は要素 1, 2, 3 をもつベクタを表す構文データであり， {\cf '\#(1 2 3)} は対応するリテラルである。

構文データは， Scheme 式のスーパーセットである。
したがって，データは，データオブジェクトとして Scheme 式を表すために使用することができる。
特に，シンボルは識別子を表すために使用することができる。

\begin{scheme}
'(+ 23 42) \ev (+ 23 42)
'(define (f x) (+ x 42)) \lev (define (f x) (+ x 42))%
\end{scheme}

これは， Scheme のソースコード上で演算するプログラム，特に，インタプリタやプログラム変換器を書くことを容易にする。

\chapter{継続}

Scheme 式が評価されるたびに，式の結果を待つ\textit{継続}がある。
継続は，計算の全体 (デフォルト) の将来を表している。
% For example, informally the continuation of {\cf 3} in the expression
たとえば，非公式に式の {\cf 3} の継続
%
\begin{scheme}
(+ 1 3)%
\end{scheme}
%
は，それに 1 を加算する。
は，それに1を加算する。
通常，これらの遍在する継続は舞台裏に隠されており，プログラマはそれらについてあまり考えない。
しかし，まれに，プログラマが明示的に継続を扱う必要がある。

{\cf call-with-current-continuation}  手続きは， Scheme プログラマが手続きを作成することによって現在の継続を回復すること可能にする。
{\cf call-with-current-continuation}  手続きは，\textit{脱出手続き}を引数にした手続きを受けとり，すぐにそれを呼び出す。
この脱出手続きはこのとき， {\cf call-with-current-continuation} の呼び出しの結果になる引数で呼び出すことができる。
つまり，エスケープ手続きは自身の継続を放棄し， {\cf call-with-current-continuation} の呼び出しの継続を回復する。

次の例では，その引数に 1 を加算する，継続を表す脱出手続きは {\cf escape} に束縛され，その後 3 を引数にして呼ばれる。
{\cf escape} の呼び出しの継続は放棄され，代わりに， 3 が 1 を加算する継続に渡される。
%
\begin{scheme}
(+ 1 (call-with-current-continuation
       (lambda (escape)
         (+ 2 (escape 3))))) \lev 4%
\end{scheme}
%
脱出手続きは，無制限の範囲を有する:
それは捕捉された継続が呼び出された後に呼び出すことができ，複数回呼び出すことができる。
これは， {\cf call-with-current-continuation} を，他の言語における例外のような典型的な非局所制御構文よりもはるかに強力にする。

\chapter{ライブラリ}

Scheme のコードは，\textit{ライブラリ}と呼ばれるコンポーネントに編成することができる。
各ライブラリには，定義および式が含まれている。
それは他のライブラリとエクスポート定義から，他のライブラリに定義をインポートすることができる。

{\cf (hello)} と呼ばれる次のライブラリは， {\cf hello-world} と呼ばれる定義をエクスポートし，基本ライブラリと表示ライブラリをインポートする。
{\cf hello-world} エクスポートは，別の行に {\cf Hello World} と表示する手続きである:
%
\begin{scheme}
(define-library (hello)
  (export hello-world)
  (import (scheme base)
          (scheme display))
  (begin
    (define (hello-world)
      (display "Hello World")
      (newline))))%
\end{scheme}

\chapter{プログラム}

ライブラリは他のライブラリによって呼び出されるが，最終的には Scheme \textit{プログラム}によって呼び出される。
ライブラリのように，プログラムはインポート，定義および式が含まれており，実行のためのエントリポイントを指定する。
したがってプログラムは，それをインポートするライブラリの推移閉包を経由して Scheme プログラムを定義している。

次のプログラムは，プロセスコンテキストライブラリから {\cf command-line} 手続きを経由してコマンドラインからの最初の引数を取得する。
その後，ファイルが現在の入力ポートを発生させる {\cf with-input-from-file} を使用してファイルを開き，それが最後に閉じられるために手配する。
次に，ファイルからテキスト行を読み取るために {\cf read-line} 手続きを，その後，行を出力するために {\cf write-string} と {\cf newline} を呼び出し，ファイルの最後までループしている:
%
\begin{scheme}
(import (scheme base)
        (scheme file)
        (scheme process-context))
(with-input-from-file
  (cadr (command-line))
  (lambda ()
    (let loop ((line (read-line)))
      (unless (eof-object? line)
        (write-string line)
        (newline)
        (loop (read-line))))))%
\end{scheme}

\chapter{REPL}

実装は，インポート宣言，式および定義が入力され，一つずつ評価される \defining{REPL} (read-eval-printループ) と呼ばれる対話型セッションを提供してもよい。
REPL は，基本ライブラリおよび，おそらく他のライブラリがインポートされて始まる。
実装は， REPL がその入力をファイルから読み取る動作モードを提供してもよい。
このようなファイルは，一般的には，先頭以外の場所でインポート宣言を含めることができるので，プログラムと同じではない。

ここに短い REPL セッションがある。
{\cf >} 文字は入力のための REPL のプロンプトを表す。

\begin{scheme}
> ; A few simple things
> (+ 2 2)
4
> (sin 4)
Undefined variable: sin
> (import (scheme inexact))
> (sin 4)
-0.756802495307928
> (define sine sin)
> (sine 4)
-0.756802495307928
> ; Guy Steele's three-part test
> ; True is true ...
> \#t
\#t
> ; 100!/99! = 100 ...
> (define (fact n)
    (if (= n 0) 1 (* n (fact (- n 1)))))
> (/ (fact 100) (fact 99))
100
> ; If it returns the *right* complex number,
> ; so much the better ...
> (define (atanh x)
    (/ (- (log (+ 1 x))
          (log (- 1 x)))
       2))
> (atanh -2)
-0.549306144334055+1.5707963267949i%
\end{scheme}

%%% Local Variables: 
%%% mode: latex
%%% End: 
